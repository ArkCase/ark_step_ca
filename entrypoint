#!/bin/bash

set -eou pipefail
. /.functions
define_base_vars

cleanup()
{
	[ -v DAEMON_PID ] && kill -TERM "${DAEMON_PID}" &>/dev/null
}

join_array()
{
	local IFS="${1}"
	shift
	echo "${*}"
}

# Paraphrased from:
# https://github.com/influxdata/influxdata-docker/blob/0d341f18067c4652dfa8df7dcb24d69bf707363d/influxdb/2.0/entrypoint.sh
# (a repo with no LICENSE.md)

export STEPPATH="$(step path)"
export CONFIG_PATH="${STEPPATH}/config/ca.json"
export PASSWORD_PATH="${STEPPATH}/secrets/password"

if [ -f "${PASSWORD_PATH}" ] ; then
	# Make sure our existing password exactly matches our
	# incoming password. If they don't, then we must nuke
	# the existing configurations so we can create new ones
	# using this new password. Or, perhaps, change the existing
	# certificate's password?
	read OLD_PASSWORD REST < <(/usr/bin/sha256sum "${PASSWORD_PATH}")

	if [ -v DOCKER_STEPCA_INIT_PASSWORD_FILE ] ; then
		read NEW_PASSWORD REST < <(/usr/bin/sha256sum "${DOCKER_STEPCA_INIT_PASSWORD_FILE}")
	elif [ -v DOCKER_STEPCA_INIT_PASSWORD ]; then
		read NEW_PASSWORD REST < <(echo -n "${DOCKER_STEPCA_INIT_PASSWORD}" | /usr/bin/sha256sum)
	fi

	if [ "${NEW_PASSWORD:-""}" != "${OLD_PASSWORD}" ] ; then
		say "⚠️ The incoming password and the existing password don't match, the configuration must be re-initialized"
		/usr/bin/find "${STEPPATH}" -delete &>/dev/null || true
		FILES="$(/usr/bin/find "${STEPPATH}" -type f | /usr/bin/wc -l)"
		[ "${FILES}" -le 0 ] || fail "Failed to clear out the existing data at [${STEPPATH}] ... please remove it manually."
	fi
fi

# List of env vars required for step ca init
declare -ra REQUIRED_INIT_VARS=(DOCKER_STEPCA_INIT_NAME DOCKER_STEPCA_INIT_DNS_NAMES)

if [ ! -v DOCKER_STEPCA_INIT_DNS_NAMES ] || [ "${DOCKER_STEPCA_INIT_DNS_NAMES,,}" == "<auto>" ] ; then

	# Unset this in case we were explicitly told to autocompute them
	[ -v DOCKER_STEPCA_INIT_DNS_NAMES ] && unset DOCKER_STEPCA_INIT_DNS_NAMES

	# We weren't given names, so compute them
	if [ -v KUBERNETES_SERVICE_HOST ] ; then

		# We're in K8s, so proceed accordingly
		FQDN="$(/usr/bin/hostname -f)"
		FQSN=""
		IFS="." read POD SERVICE NAMESPACE SVC CLUSTER_DOMAIN <<< "${FQDN}"

		NAMES=()

		# DOCKER_STEPCA_INIT_SERVICE_NAME is the "consumable" service,
		# while SERVICE is the (possibly headless) default service
		# associated to a pod. They *may* be the same but aren't
		# required to be. Thus, we check to see if they're the same,
		# to avoid adding duplicate values
		[ -v DOCKER_STEPCA_INIT_SERVICE_NAME ] || DOCKER_STEPCA_INIT_SERVICE_NAME="${SERVICE}"
		if [ "${DOCKER_STEPCA_INIT_SERVICE_NAME}" != "${SERVICE}" ] ; then
			if [ -n "${NAMESPACE}" ] ; then
				if [ -n "${CLUSTER_DOMAIN}" ] ; then
					[ -n "${FQSN}" ] || FQSN="${DOCKER_STEPCA_INIT_SERVICE_NAME}.${NAMESPACE}.svc.${CLUSTER_DOMAIN}"
					NAMES+=("${FQSN}")
				fi
				NAMES+=("${DOCKER_STEPCA_INIT_SERVICE_NAME}.${NAMESPACE}")
			fi
			NAMES+=("${DOCKER_STEPCA_INIT_SERVICE_NAME}")
			SVC_VAR="${DOCKER_STEPCA_INIT_SERVICE_NAME^^}_SERVICE_HOST"
			if [ -v "${SVC_VAR}" ] ; then
				SVC_IP="$(is_valid_ipv4 "${!SVC_VAR}")" && [ "${SVC_IP}" != "127.0.0.1" ] && NAMES+=("${SVC_IP}")
			fi
		fi

		if [ -n "${SERVICE}" ] ; then
			if [ -n "${NAMESPACE}" ] ; then
				if [ -n "${CLUSTER_DOMAIN}" ] ; then
					[ -n "${FQSN}" ] || FQSN="${SERVICE}.${NAMESPACE}.svc.${CLUSTER_DOMAIN}"
					NAMES+=(
						"${POD}.${SERVICE}.${NAMESPACE}.svc.${CLUSTER_DOMAIN}"
						"${SERVICE}.${NAMESPACE}.svc.${CLUSTER_DOMAIN}"
					)
				fi
				NAMES+=(
					"${POD}.${SERVICE}.${NAMESPACE}"
					"${SERVICE}.${NAMESPACE}"
				)
			fi
			NAMES+=(
				"${POD}.${SERVICE}"
				"${SERVICE}"
			)
			SVC_VAR="${SERVICE^^}_SERVICE_HOST"
			if [ -v "${SVC_VAR}" ] ; then
				SVC_IP="$(is_valid_ipv4 "${!SVC_VAR}")" && [ "${SVC_IP}" != "127.0.0.1" ] && NAMES+=("${SVC_IP}")
			fi
		fi

		NAMES+=(
			"${POD}"
			"localhost.localdomain"
			"localhost"
		)

		if [ -v POD_IP ] ; then
			POD_IP="$(is_valid_ipv4 "${POD_IP}")" && [ "${POD_IP}" != "127.0.0.1" ] && NAMES+=("${POD_IP}")
		fi
		NAMES+=("127.0.0.1")

		DOCKER_STEPCA_INIT_DNS_NAMES="$(join_array "," "${NAMES[@]}")"
		[ -n "${DOCKER_STEPCA_INIT_DNS_NAMES}" ] || unset DOCKER_STEPCA_INIT_DNS_NAMES
	else
		FQDN="$(hostname -f)"
		HN="$(hostname -s)"
		[ "${HN}" == "${FQDN}" ] || FQDN="${FQDN},${HN}"
		DOCKER_STEPCA_INIT_DNS_NAMES="localhost,localhost.localdomain,${FQDN}"
	fi

	if [ -n "${DOCKER_STEPCA_INIT_DNS_NAMES}" ] ; then
		say "👉 Computed DOCKER_STEPCA_INIT_DNS_NAMES=[${DOCKER_STEPCA_INIT_DNS_NAMES}]"
	else
		unset DOCKER_STEPCA_INIT_DNS_NAMES
	fi
fi

# Ensure all env vars required to run step ca init are set.
init_if_possible()
{

	local FAILED=()
	for VAR in "${REQUIRED_INIT_VARS[@]}"; do
		[ -v "${VAR}" ] || FAILED+=("${VAR}")
	done

	[ ${#FAILED[@]} -le 0 ] || fail "There is no config file at [${CONFIG_PATH}]; please run step ca init, or provide values for these variables: ${FAILED[@]}"

	# Everything is available for initialization
	step_ca_init "${@}"
}

# Initialize a CA if not already initialized
step_ca_init()
{
	DOCKER_STEPCA_INIT_PROVISIONER_NAME="${DOCKER_STEPCA_INIT_PROVISIONER_NAME:-admin}"
	DOCKER_STEPCA_INIT_ADMIN_SUBJECT="${DOCKER_STEPCA_INIT_ADMIN_SUBJECT:-step}"
	DOCKER_STEPCA_INIT_ADDRESS="${DOCKER_STEPCA_INIT_ADDRESS:-:9000}"

	local -a SETUP_ARGS=(
		--name "${DOCKER_STEPCA_INIT_NAME}"
		--dns "${DOCKER_STEPCA_INIT_DNS_NAMES}"
		--provisioner "${DOCKER_STEPCA_INIT_PROVISIONER_NAME}"
		--password-file "${STEPPATH}/password"
		--provisioner-password-file "${STEPPATH}/provisioner_password"
		--address "${DOCKER_STEPCA_INIT_ADDRESS}"
	)
	if [ -v DOCKER_STEPCA_INIT_PASSWORD_FILE ] ; then
		[ -s "${DOCKER_STEPCA_INIT_PASSWORD_FILE}" ] || fail "The password file at [${DOCKER_STEPCA_INIT_PASSWORD_FILE}] may not be empty."
		cat "${DOCKER_STEPCA_INIT_PASSWORD_FILE}" | tee "${STEPPATH}/password" > "${STEPPATH}/provisioner_password"
	elif [ -v DOCKER_STEPCA_INIT_PASSWORD ]; then
		[ -n "${DOCKER_STEPCA_INIT_PASSWORD}" ] || fail "The password from [${DOCKER_STEPCA_INIT_PASSWORD}] may not be empty."
		echo -n "${DOCKER_STEPCA_INIT_PASSWORD}" | tee "${STEPPATH}/password" > "${STEPPATH}/provisioner_password"
	else
		fail "Must provide a pre-set password using either DOCKER_STEPCA_INIT_PASSWORD or DOCKER_STEPCA_INIT_PASSWORD_FILE"
	fi
	set_as_boolean DOCKER_STEPCA_INIT_SSH
	if "${DOCKER_STEPCA_INIT_SSH}"; then
		SETUP_ARGS+=(--ssh)
	fi
	set_as_boolean DOCKER_STEPCA_INIT_ACME
	if "${DOCKER_STEPCA_INIT_ACME}"; then
		SETUP_ARGS+=(--acme)
	fi
	set_as_boolean DOCKER_STEPCA_INIT_REMOTE_MANAGEMENT
	if "${DOCKER_STEPCA_INIT_REMOTE_MANAGEMENT}"; then
		SETUP_ARGS+=(--remote-management)
		SETUP_ARGS+=(--admin-subject "${DOCKER_STEPCA_INIT_ADMIN_SUBJECT}")
	fi
	step ca init "${SETUP_ARGS[@]}"

	START_DATE="$(date -u +%s -d "2 hours ago")"
	NOT_BEFORE="$(date -Isec -u -d "@${START_DATE}")"
	END_DATE="$(date -u +%s -d "5 years")"
	NOT_AFTER="$(date -Isec -u -d "@${END_DATE}")"

	set_or_default POD_NAMESPACE
	set_or_default PARENT_CA_CRT
	set_or_default PARENT_CA_KEY

	set_or_default KEYBITS 2048
	[[ "${KEYBITS}" =~ ^[1-9][0-9]*$ ]] || fail "The bit size [${KEYBITS}] is invalid"

	KEY="${STEPPATH}/secrets/root_ca_key"
	CERT="${STEPPATH}/certs/root_ca.crt"
	PASS="${STEPPATH}/password"
	if [ -n "${PARENT_CA_CRT}" ] && [ -n "${PARENT_CA_KEY}" ] && is_file_readable "${PARENT_CA_CRT}" && is_file_readable "${PARENT_CA_KEY}" ; then
		say "👉 An existing parent CA has been provided and found, using it:"
		openssl x509 -noout -in "${PARENT_CA_CRT}" -subject -issuer | sed -e 's;^;\t;g'

		# Per: https://smallstep.com/docs/tutorials/intermediate-ca-new-ca/index.html#the-secure-way
		shred -u "${CERT}" || fail "Failed to shred the existing CA certificate"
		cp -vf "${PARENT_CA_CRT}" "${CERT}" || \
			fail "Failed to copy the parent CA from [${PARENT_CA_CRT}] into its final location in [${CERT}]"

		shred -u "${KEY}" || fail "Failed to shred the existing CA's key at [${KEY}]"

		if [ -v PARENT_CA_PASS ] && [ -n "${PARENT_CA_PASS}" ] ; then
			# Decrypt the incoming key
			if is_file_readable "${PARENT_CA_PASS}" ; then
				PARENT_CA_PASS_FILE="$(readlink -f "${PARENT_CA_PASS}")" || fail "Failed to canonicalize the path for the parent CA's password (from [${PARENT_CA_PASS}])"
				openssl rsa -in "${PARENT_CA_KEY}" -out "${KEY}" -passin "file:${PARENT_CA_PASS_FILE}" || fail "Failed to decrypt the parent CA's key"
			else
				echo -n "${PARENT_CA_PASS}" | openssl rsa -in "${PARENT_CA_KEY}" -out "${KEY}" -passin stdin || fail "Failed to decrypt the parent CA's key"
			fi
		else
			# Copy without decrypting
			cp -vf "${PARENT_CA_KEY}" "${KEY}" || \
				fail "Failed to copy the parent CA's key from [${PARENT_CA_KEY}] into its final location in [${KEY}]"
		fi

		# Re-encrypt, but using our password
		openssl rsa -aes256 -in "${KEY}" -out "${KEY}.enc" -passout "file:${PASS}"
		# Replace the unencrypted one with the encrypted one
		mv -vf "${KEY}.enc" "${KEY}" || \
			fail "Failed to replace the unencrypted CA's key with the encrypted key"
	else
		say "👉 Creating a stronger root CA (${KEYBITS} bits)..."

		# First, generate the key
		openssl genrsa -out "${KEY}" -passout "file:${PASS}" ${KEYBITS} || fail "Failed to render a new private key for the CA"

		# Now, generate a self-signed CA with a start date in the past
		# to accommodate possible clock skew between nodes
		(
			set -euo pipefail

			cleanup()
			{
				[ -v TRASH ] && [ -d "${TRASH}" ] && rm -rf "${TRASH}" &>/dev/null
			}

			TRASH="$(mktemp -d)"
			trap cleanup EXIT
			mkdir -p "${TRASH}/certs" "${TRASH}/crls"
			touch "${TRASH}/index" "${TRASH}/serial"

			OPENSSL_CONFIG="$(cat <<-EOF
			[ req ]
			distinguished_name  = dn
			[ dn ]
			[ ca ]
			default_ca          = CA_default
			[ CA_default ]
			dir                 = ${TRASH}
			new_certs_dir       = ${TRASH}/certs
			crl_dir             = ${TRASH}/crls
			serial              = ${TRASH}/serial
			rand_serial         = yes
			crl                 = ${TRASH}/ca-crl.pem
			database            = ${TRASH}/index
			private_key         = ${KEY}
			certificate         = ${CERT}
			default_md          = sha256
			policy              = policy_any
			[ ext ]
			basicConstraints    = critical,CA:TRUE,pathlen:1
			keyUsage            = critical,keyCertSign,cRLSign
			[ policy_any ]
			commonName             = supplied
			countryName            = optional
			stateOrProvinceName    = optional
			organizationName       = optional
			organizationalUnitName = optional
			emailAddress           = optional
			EOF
			)"

			REQ="${TRASH}/ca.csr"
			SUBJECT="/CN=ArkCase Root CA/OU=${POD_NAMESPACE}/"
			openssl req \
				-new \
				-nodes \
				-key "${KEY}" \
				-passin "file:${PASS}" \
				-subj "${SUBJECT}" \
				-out "${REQ}" || fail "Failed to render a new CA request"

			openssl ca \
				-batch \
				-selfsign \
				-in "${REQ}" \
				-config <(echo "${OPENSSL_CONFIG}") \
				-days 36500 \
				-noemailDN \
				-startdate "$(date +"%y%m%d%H%M%SZ" -d "@${START_DATE}")" \
				-enddate "$(date +"%y%m%d%H%M%SZ" -d "@${END_DATE}")" \
				-extensions ext \
				-out "${CERT}" || fail "Failed to self-sign the new CA certificate"
		) || fail "Failed to render a new CA certificate"
	fi

	say "👉 Creating an intermediate CA..."
	OUT="$(
		set -x
   		step certificate create \
			--profile intermediate-ca \
			--kty RSA \
			--size 2048 \
			--force \
			--not-before="${NOT_BEFORE}" \
			--not-after="${NOT_AFTER}" \
			--password-file "${PASS}" \
			--ca "${CERT}" \
			--ca-key "${KEY}" \
			--ca-password-file "${PASS}" \
			"${DOCKER_STEPCA_INIT_NAME} Intermediate CA" \
			"${STEPPATH}/certs/intermediate_ca.crt" "${STEPPATH}/secrets/intermediate_ca_key"
	)" || fail "Failed to generate the stronger intermediate CA (rc=${?}):\n${OUT}"

	echo ""
	[ "${DOCKER_STEPCA_INIT_REMOTE_MANAGEMENT}" == "true" ] && say "👉 Your CA administrative username is: ${DOCKER_STEPCA_INIT_ADMIN_SUBJECT}"
	say "👉 Your CA administrative password is: $(< "${STEPPATH}/provisioner_password" )"
	say "🤫 This will only be displayed once."
	shred -u "${STEPPATH}/provisioner_password"
	mv "${PASS}" "${PASSWORD_PATH}"
}

[ -f /usr/sbin/pcscd ] && /usr/sbin/pcscd

ROOT_CA="${STEPPATH}/certs/root_ca.crt"
if is_file_readable "${ROOT_CA}" && [ -s "${ROOT_CA}" ] ; then
	SUM="$(sha256sum "${ROOT_CA}" 2>&1)" || fail "Failed to compute the SHA256 sum for [${ROOT_CA}] (rc=${?}): ${SUM}"
else
	init_if_possible
fi

#
# This is the daemon command
#
CMD=( /usr/bin/step-ca --password-file "${PASSWORD_PATH}" "${CONFIG_PATH}" )

#
# If we're fully configured, then we exec() into Step-CA
#
if check-configured &>/dev/null ; then
	ok "The instance is fully configured! The daemon will run in the foreground"
	exec "${CMD[@]}"
fi

#
# If we're not fully configured, some black magic is required
#
# We use coproc b/c it lets us run the daemon in the background
# in a controlled fashion with full access to everything. The
# redirects are meant to facilitate the command's output being
# piped to our STDOUT directly
#
warn "The instance is not yet fully configured"

running "The daemon will run in the background as a coprocess for this execution"
exec 7>&1
coproc "${CMD[@]}" 1>&7 2>&1

export DAEMON_PID="${COPROC_PID}"
trap cleanup EXIT
eyes "The daemon is running with pid ${DAEMON_PID}"

#
# Start the reconfiguration script
#
reconfigure "${DAEMON_PID}" || fail "Failed to reconfigure the Step-CA instance"

#
# Everything's ready! Wait on the Step-CA daemon
#
wait "${DAEMON_PID}" || fail "Failed to wait for the Step-CA daemon (pid=${DAEMON_PID}, rc=${?})"
quit "Execution complete"
